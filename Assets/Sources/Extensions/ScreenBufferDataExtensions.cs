using System;
using System.Collections.Generic;

public static class ScreenBufferStateExtensions {

	/// Fills the buffer data with values generated by a function of pixel coordinates.
	public static void Fill(this ScreenBufferState data, Func<int, int, ColorCode> function) {

		for (int y = 0; y < data.size.y; ++y) {
			for (int x = 0; x < data.size.x; ++x) {

				data.SetColorCodeAt(x, y, function(x, y));
			}
		}
	}

	/// Fills the buffer data with a specified color.
	public static void Fill(this ScreenBufferState data, ColorCode colorCode) {

		for (int y = 0; y < data.size.y; ++y) {
			for (int x = 0; x < data.size.x; ++x) {

				data.SetColorCodeAt(x, y, colorCode);
			}
		}
	}

    public static Dictionary<char, byte> characterToByte;
    public static uint[] characterData;

    static ScreenBufferStateExtensions() {
		
        characterToByte = new Dictionary<char, byte>();
        string characters = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
		for(int i = 0; i < characters.Length; i++) {
			
            characterToByte[characters[i]] = (byte)(i + 32);
        }

        characterData = new uint[] {
/* 0    */  0xb79e388e, 0x722c75f4, 0x19bb7f8f, 0x85f9b158, 0x242e2400, 0x082a0800, 0x00080000, 0x08080808,
/* 8    */  0x00ff0000, 0x00f08080, 0x08f80000, 0x080f0000, 0x000f0808, 0x00ff0808, 0x08f80808, 0x08ff0000,
/* 16   */  0x080f0808, 0x08ff0808, 0x663399cc, 0x993366cc, 0xfef8e080, 0x7f1f0701, 0x01071f7f, 0x80e0f8fe,
/* 24   */  0x5500aa00, 0x55aa55aa, 0xffaaff55, 0x0f0f0f0f, 0xf0f0f0f0, 0x0000ffff, 0xffff0000, 0xffffffff,
/* 32   */  0x00000000, 0x005f0000, 0x03000300, 0x3e143e00, 0x266b3200, 0x611c4300, 0x36297650, 0x00020100,
/* 40   */  0x1c224100, 0x41221c00, 0x14081400, 0x081c0800, 0x40200000, 0x08080800, 0x00400000, 0x601c0300,
/* 48   */  0x3e493e00, 0x427f4000, 0x62594600, 0x22493600, 0x0f087f00, 0x27453900, 0x3e493200, 0x61190700,
/* 56   */  0x36493600, 0x26493e00, 0x00240000, 0x40240000, 0x08142200, 0x14141400, 0x22140800, 0x02590600,
/* 64   */  0x3e595e00, 0x7e097e00, 0x7f493600, 0x3e412200, 0x7f413e00, 0x7f494100, 0x7f090100, 0x3e417a00,
/* 72   */  0x7f087f00, 0x417f4100, 0x20403f00, 0x7f087700, 0x7f404000, 0x7f067f00, 0x7f017e00, 0x3e413e00,
/* 80   */  0x7f090600, 0x3e617e00, 0x7f097600, 0x26493200, 0x017f0100, 0x3f407f00, 0x1f601f00, 0x7f307f00,
/* 88   */  0x77087700, 0x07780700, 0x71494700, 0x007f4100, 0x031c6000, 0x417f0000, 0x02010200, 0x80808000,
/* 96   */  0x00010200, 0x24547800, 0x7f443800, 0x38442800, 0x38447f00, 0x38545800, 0x087e0900, 0x48543c00,
/* 104  */  0x7f047800, 0x047d0000, 0x20403d00, 0x7f106c00, 0x017f0000, 0x7c187c00, 0x7c047800, 0x38443800,
/* 112  */  0x7c140800, 0x08147c00, 0x7c040800, 0x48542400, 0x043e4400, 0x3c407c00, 0x1c601c00, 0x7c307c00,
/* 120  */  0x6c106c00, 0x4c503c00, 0x64544c00, 0x08364100, 0x00770000, 0x41360800, 0x02010201, 0x02050200
        };
    }

	/// <summary>
	/// Displays a character on the display. Is tied to an aligned grid 4px wide by 8px tall, per original LEM1802 spec.
	/// </summary>
	/// <remarks>
	/// This utilizes the default font set of the LEM1802; manual pixel control is available from the SetPixel call.
	/// This code presumes that a display's resolution can be evenly divided into 4px w by 8 px h cells.
	/// Original font ripped from https://rdr4g0n.github.io/0x10c_SpriteStudio/.
	/// </remarks>
	/// <param name="data">The buffer that is being manipulated.</param>
	/// <param name="x">The X coordinate of where to render the character.</param>
	/// <param name="y">The Y coordinate of where to render the character.</param>
	/// <param name="c">The 32 bits that represent pixels of the character being on or off</param>
	/// <param name="foreground">The color to use for the positive space (pixels the character fills).</param>
	/// <param name="background">The color to use for the negative space (pixels the character doesn't fill.</param>
	public static void WriteChar(this ScreenBufferState data, int x, int y, uint character, ColorCode foreground, ColorCode background) {
		
		// Filter the cell indices, and multiply the amounts by the cell sizes.
		x = (x % (data.size.x / 4)) * 4;
		y = (y % (data.size.y / 8)) * 8;

		for (int i = 31; i >= 0; i--) {

			int pixelX = x + (i / 8), pixelY = y + 7 - (i % 8);

			bool filled = ((character >> (31 - i)) & 1) == 1;

			data.SetColorCodeAt(pixelX, pixelY, (filled ? foreground : background));
		}
	}

    /// <summary>
    /// Displays a character on the display. Is tied to an aligned grid 4px wide by 8px tall, per original LEM1802 spec.
    /// </summary>
    /// <remarks>
    /// This utilizes the default font set of the LEM1802; manual pixel control is available from the SetPixel call.
    /// This code presumes that a display's resolution can be evenly divided into 4px w by 8 px h cells.
    /// Original font ripped from https://rdr4g0n.github.io/0x10c_SpriteStudio/.
    /// </remarks>
    /// <param name="data">The buffer that is being manipulated.</param>
    /// <param name="x">The X coordinate of where to render the character.</param>
    /// <param name="y">The Y coordinate of where to render the character.</param>
    /// <param name="c">The index of the character to render.</param>
    /// <param name="foreground">The color to use for the positive space (pixels the character fills).</param>
    /// <param name="background">The color to use for the negative space (pixels the character doesn't fill.</param>
    public static void WriteChar(this ScreenBufferState data, int x, int y, byte characterIndex, ColorCode foreground, ColorCode background) {


        // Fill character based on c
        // Just pulls a specific index from a constant array filled (by hand!) from linked source
		data.WriteChar(x, y, characterData[characterIndex], foreground, background);
    }

    /// <summary>
    /// Displays a character on the display. Is tied to an aligned grid 4px wide by 8px tall, per original LEM1802 spec.
    /// </summary>
    /// <remarks>
    /// This is just a helper method for the version of WriteChar that uses a byte.
    /// </remarks>
    /// <param name="data">The buffer that is being manipulated.</param>
    /// <param name="x">The X coordinate of where to render the character.</param>
    /// <param name="y">The Y coordinate of where to render the character.</param>
    /// <param name="c">Which character to render.</param>
    /// <param name="foreground">The color to use for the positive space (pixels the character fills).</param>
    /// <param name="background">The color to use for the negative space (pixels the character doesn't fill.</param>
	public static void WriteChar(this ScreenBufferState data, int x, int y, char c, ColorCode foreground, ColorCode background) {
		
        data.WriteChar(x, y, characterToByte[c], foreground, background);
    }

    /// <summary>
    /// Displays a string on the display.  Is tied to an aligned grid 4px wide by 8px tall, per original LEM1802 spec.
    /// </summary>
    /// <param name="data">The buffer that is being manipulated.</param>
    /// <param name="x">The X coordinate of where to begin rendering the string.</param>
    /// <param name="y">The Y coordinate of where to begin rendering the string.</param>
    /// <param name="s">The string to render.</param>
    /// <param name="foreground">The color to use for the positive space (pixels the character fills).</param>
    /// <param name="background">The color to use for the negative space (pixels the character doesn't fill.</param>
    public static void WriteStr(this ScreenBufferState data, int x, int y, string s, ColorCode foreground, ColorCode background) {
		
        for (int i = 0; i < s.Length; i++) {
			
            if (x * 4 >= data.size.x) {
                y++;
                x = 0;
            }

            if (y * 8 >= data.size.y) {
                y = 0;
            }

            data.WriteChar(x, y, s[i], foreground, background);
            x++;
        }
    }
}
